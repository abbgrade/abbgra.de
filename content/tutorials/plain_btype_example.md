title: Plain Btype Example
description: How to create simple btypes and use them.
type: tutorial
category: tutorials
tags: [blob_types, python]
date: 2014-02-09
---
Import the packages to test if everything is installed.

    ::Python
	import blob_types
    from blob_types import *
    import numpy
    blob_types.__version__

Output:

    '0.13.3'


Define a type and create a test instance.

    ::Python
	class Vector3(Blob):
        
        dtype, subtypes = Blob.create_plain_dtype(
            ('x', numpy.float32),
            ('y', numpy.float32),
            ('z', numpy.float32)
        )
        
        def __repr__(self):
            return 'This object is based on %s = %s, with a %s of %d bytes.' % (
                type(self.blob), 
                repr(self.blob), 
                type(self.blob.data), 
                len(self.blob.data)
            )
    
    Vector3(x=1, y=2, z=3)

Output:

    ::Plain
    This object is based on <type 'numpy.void'> = (1.0, 2.0, 3.0), with a <type 'buffer'> of 12 bytes.

Create simple nested type.

    ::Python
	class Matrix3x3(Blob):
        
        dtype, subtypes = Blob.create_plain_dtype(
            ('x', Vector3),
            ('y', Vector3),
            ('z', Vector3)
        )
        
        def __repr__(self):
            return 'This object is based on %s = %s, with a %s of %d bytes.' % (
                type(self.blob), 
                repr(self.blob), 
                type(self.blob.data), 
                len(self.blob.data)
            )
        
    Matrix3x3.from_struct(
        {
            'x':{'x':1, 'y':0, 'z':0},
            'y':{'x':0, 'y':1, 'z':0},
            'z':{'x':0, 'y':0, 'z':1}
        }
    )

Output:

    ::Plain
    This object is based on <type 'numpy.void'> = (1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0), with a <type 'buffer'> of 36 bytes.

Generate the C functions to work with the data.

    ::Python
	import pyopencl
    import pyopencl.tools
    pyopencl.create_some_context(False)
    pyopencl.tools.get_or_register_dtype(BlobLib.get_interface(Matrix3x3).get_name('global'), Matrix3x3.dtype)
    
    vector_lib = BlobLib(required_global_blob_types=[Matrix3x3])

Thats everything you need to work with the blobs.

The header code:

    ::Python
	with open('vector_lib.h', 'wb') as fh:
        fh.write(vector_lib.header_code)

    with open('vector_lib.cl', 'wb') as fh:
        fh.write(vector_lib.source_code)

    print '/* content of vector_lib.h */'
    print vector_lib.header_code
    
Output:
    
    ::C
    /* content of vector_lib.h */
    /* header generated by C:\Python27\lib\site-packages\blob_types\interface.pyc */
    
    
    
    /* plain type vector3_gt */
    
    typedef struct __attribute__((__packed__)) _vector3_gt
    {
    	float x;
    	float y;
    	float z;
    } vector3_gt;
    
    /* plain type matrix3x3_gt */
    
    typedef struct __attribute__((__packed__)) _matrix3x3_gt
    {
    	float x_x;
    	float x_y;
    	float x_z;
    	float y_x;
    	float y_y;
    	float y_z;
    	float z_x;
    	float z_y;
    	float z_z;
    } matrix3x3_gt;
    
    unsigned long sizeof_vector3_gt(global char* blob);
    
    void copy_vector3_gt(global vector3_gt* source, global vector3_gt* destination);
    
    unsigned long sizeof_matrix3x3_gt(global char* blob);
    
    void copy_matrix3x3_gt(global matrix3x3_gt* source, global matrix3x3_gt* destination);
    
    global vector3_gt * get_matrix3x3_gt_x(global matrix3x3_gt* self);
    
    global vector3_gt * get_matrix3x3_gt_y(global matrix3x3_gt* self);
    
    global vector3_gt * get_matrix3x3_gt_z(global matrix3x3_gt* self);
   
The source code:
    
    ::Python
    print '/* content of vector_lib.cl */'
    print vector_lib.source_code
    
Output:
    
    ::C
    /* content of vector_lib.cl */
    /* source generated by C:\Python27\lib\site-packages\blob_types\interface.pyc */
    
    unsigned long sizeof_vector3_gt(global char* blob)
    {
        return sizeof(vector3_gt);
    };
    
    void copy_vector3_gt(global vector3_gt* source, global vector3_gt* destination)
    {
    	destination->x = source->x;
    	destination->y = source->y;
    	destination->z = source->z;
    };
    
    unsigned long sizeof_matrix3x3_gt(global char* blob)
    {
        return sizeof(matrix3x3_gt);
    };
    
    void copy_matrix3x3_gt(global matrix3x3_gt* source, global matrix3x3_gt* destination)
    {
    	destination->x_x = source->x_x;
    	destination->x_y = source->x_y;
    	destination->x_z = source->x_z;
    	destination->y_x = source->y_x;
    	destination->y_y = source->y_y;
    	destination->y_z = source->y_z;
    	destination->z_x = source->z_x;
    	destination->z_y = source->z_y;
    	destination->z_z = source->z_z;
    };
    
    global vector3_gt * get_matrix3x3_gt_x(global matrix3x3_gt* self)
    {
        return (global vector3_gt *)&self->x_x;
    };
    
    global vector3_gt * get_matrix3x3_gt_y(global matrix3x3_gt* self)
    {
        return (global vector3_gt *)&self->y_x;
    };
    
    global vector3_gt * get_matrix3x3_gt_z(global matrix3x3_gt* self)
    {
        return (global vector3_gt *)&self->z_x;
    };



    

